ifelse(p < 0.1, ".", ""))))
}
tableau <- data.frame(
Etat = rep(rownames(coef_mat), each = ncol(coef_mat)),
Parametre = rep(colnames(coef_mat), times = nrow(coef_mat)),
Coefficient = as.vector(coef_mat),
SE = as.vector(se_mat),
z = as.vector(z_mat),
p_value = as.vector(p_mat)
) %>%
mutate(
Coefficient = round(Coefficient, 4),
SE = round(SE, 4),
z = round(z, 3),
p_value = signif(p_value, 3),
Signif = etoiles(p_value)
)
kable(tableau, format = "html", booktabs = TRUE,
caption = "Régression multinomiale : effets des strates de recouvrement sur la phénologie") %>%
kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
# ------------------------------------------------------------
# 1. Taux d’erreur d’adéquation par observateur
# ------------------------------------------------------------
verification3 <- verification %>%
group_by(observateur) %>%
count(adequation) %>%
pivot_wider(
names_from = adequation,
values_from = n,
names_glue = "{ifelse(adequation == 1, 'id_valide', 'id_fausse')}"
) %>%
replace_na(list(
id_valide = 0,
id_fausse = 0
)) %>%
mutate(
id_total = id_valide + id_fausse,
tx_erreur = id_fausse / id_total
)
verification3 <- verification3 %>%
left_join(
experience %>% dplyr::select(Observateur, sexe),
by = c("observateur" = "Observateur")
)
# Vérification des adéquations manquantes
verification %>%
filter(is.na(adequation))
# ------------------------------------------------------------
# 2. Score moyen d’auto-évaluation (A à E)
# ------------------------------------------------------------
experience <- experience %>%
mutate(
score_moyen = rowMeans(across(A:E), na.rm = TRUE),
fiabilite = score_moyen / 10,
risque_erreur = 1 - fiabilite
)
# Variabilité intra-observateur
experience <- experience %>%
rowwise() %>%
mutate(ecart_type = sd(c_across(A:E), na.rm = TRUE)) %>%
ungroup()
# Classement par risque d’erreur
experience <- experience %>%
arrange(desc(risque_erreur)) %>%
mutate(ID.observateur = factor(ID.observateur, levels = ID.observateur))
# ------------------------------------------------------------
# 3. Fusion auto-évaluation / adéquation réelle
# ------------------------------------------------------------
experience2 <- experience %>%
inner_join(
verification3,
by = join_by("Observateur" == "observateur")
)
# ------------------------------------------------------------
# 4. Taux de détection réel par observateur
# ------------------------------------------------------------
tx_erreur <- tab_complet %>%
group_by(observateur) %>%
summarise(
nb_ind = n(),
nb_detect = sum(detection, na.rm = TRUE),
tx_detect = nb_detect / nb_ind
)
tx_erreur_fin <- experience2 %>%
inner_join(
tx_erreur,
by = join_by("Observateur" == "observateur")
)
# ------------------------------------------------------------
# 5. Graphiques
# ------------------------------------------------------------
# ------------------------------------------------------------
# 1. Taux d’erreur d’adéquation par observateur
# ------------------------------------------------------------
verification3 <- verification %>%
group_by(observateur) %>%
count(adequation) %>%
pivot_wider(
names_from = adequation,
values_from = n,
names_glue = "{ifelse(adequation == 1, 'id_valide', 'id_fausse')}"
) %>%
replace_na(list(
id_valide = 0,
id_fausse = 0
)) %>%
mutate(
id_total = id_valide + id_fausse,
tx_erreur = id_fausse / id_total
)
verification3 <- verification3 %>%
left_join(
experience %>% dplyr::select(Observateur, sexe),
by = c("observateur" = "Observateur")
)
# Vérification des adéquations manquantes
verification %>%
filter(is.na(adequation))
# ------------------------------------------------------------
# 2. Score moyen d’auto-évaluation (A à E)
# ------------------------------------------------------------
experience <- experience %>%
mutate(
score_moyen = rowMeans(across(A:E), na.rm = TRUE),
fiabilite = score_moyen / 10,
risque_erreur = 1 - fiabilite
)
# Variabilité intra-observateur
experience <- experience %>%
rowwise() %>%
mutate(ecart_type = sd(c_across(A:E), na.rm = TRUE)) %>%
ungroup()
# Classement par risque d’erreur
experience <- experience %>%
arrange(desc(risque_erreur)) %>%
mutate(ID.observateur = factor(ID.observateur, levels = ID.observateur))
# ------------------------------------------------------------
# 3. Fusion auto-évaluation / adéquation réelle
# ------------------------------------------------------------
experience2 <- experience %>%
inner_join(
verification3,
by = join_by("Observateur" == "observateur")
)
# ------------------------------------------------------------
# 4. Taux de détection réel par observateur
# ------------------------------------------------------------
tx_erreur <- tab_complet %>%
group_by(observateur) %>%
summarise(
nb_ind = n(),
nb_detect = sum(detection, na.rm = TRUE),
tx_detect = nb_detect / nb_ind
)
tx_erreur_fin <- experience2 %>%
inner_join(
tx_erreur,
by = join_by("Observateur" == "observateur")
)
# ------------------------------------------------------------
# 5. Graphiques
# ------------------------------------------------------------
ggplot(tx_erreur_fin, aes(x = tx_erreur, y = 1 - tx_detect)) +
geom_point(
aes(color = sexe.x, size = id_total),
alpha = 0.8
) +
geom_smooth(
method = "lm",
se = TRUE,
color = "red",
fill = "pink",
alpha = 0.3
) +
geom_text_repel(
aes(label = Observateur, color = sexe.x),
size = 3,
max.overlaps = Inf,
force = 5,
box.padding = 0.6,
point.padding = 0.5,
segment.color = "grey60",
segment.size = 0.4
) +
scale_color_manual(values = c("f" = "#E41A1C", "m" = "#377EB8")) +
scale_size_continuous(range = c(2, 8)) +
labs(
title = "Relation entre taux d'erreur d'attribution et non-détection",
x = "Taux d'erreur d'attribution de la phénologie",
y = "Taux de non-détection",
color = "Sexe",
size = "Nombre d'observations"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1)
)
ggplot(tx_erreur_fin, aes(x = risque_erreur, y = tx_erreur)) +
geom_point(
aes(color = sexe.x, size = id_total),
alpha = 0.8
) +
geom_smooth(
method = "lm",
se = TRUE,
color = "red",
fill = "pink",
alpha = 0.3
) +
geom_text_repel(
aes(label = Observateur, color = sexe.x),
size = 3,
max.overlaps = Inf,
force = 5,
box.padding = 0.6,
point.padding = 0.5,
segment.color = "grey60",
segment.size = 0.4
) +
scale_color_manual(values = c("f" = "#E41A1C", "m" = "#377EB8")) +
scale_size_continuous(range = c(2, 8)) +
labs(
title = "Relation entre risque d'erreur (auto-évaluation) et erreur d'attribution",
x = "Risque d'erreur basé sur l'auto-évaluation",
y = "Taux d'erreur d'attribution de la phénologie",
color = "Sexe",
size = "Nombre d'observations"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1)
)
ggplot(tx_erreur_fin, aes(x = risque_erreur, y = tx_erreur)) +
geom_point(
aes(color = sexe.x, size = id_total),
alpha = 0.8
) +
geom_smooth(
method = "lm",
se = TRUE,
color = "red",
fill = "pink",
alpha = 0.3
) +
geom_text_repel(
aes(label = Observateur, color = sexe.x),
size = 3,
max.overlaps = Inf,
force = 5,
box.padding = 0.6,
point.padding = 0.5,
segment.color = "grey60",
segment.size = 0.4
) +
scale_color_manual(values = c("f" = "#E41A1C", "m" = "#377EB8")) +
scale_size_continuous(range = c(2, 8)) +
labs(
title = "Relation entre risque d'erreur (auto-évaluation) et erreur d'attribution",
x = "Risque d'erreur basé sur l'auto-évaluation",
y = "Taux d'erreur d'attribution de la phénologie",
color = "Sexe",
size = "Nombre d'observations"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1)
)
ggplot(tx_erreur_fin, aes(x = risque_erreur, y = 1 - tx_detect)) +
geom_point(
aes(color = sexe.x, size = id_total),
alpha = 0.8
) +
geom_smooth(
method = "lm",
se = TRUE,
color = "red",
fill = "pink",
alpha = 0.3
) +
geom_text_repel(
aes(label = Observateur, color = sexe.x),
size = 3,
max.overlaps = Inf,
force = 5,
box.padding = 0.6,
point.padding = 0.5,
segment.color = "grey60",
segment.size = 0.4
) +
scale_color_manual(values = c("f" = "#E41A1C", "m" = "#377EB8")) +
scale_size_continuous(range = c(2, 8)) +
labs(
title = "Relation entre risque d'erreur (auto-évaluation) et non-détection",
x = "Risque d'erreur basé sur l'auto-évaluation",
y = "Taux de non-détection",
color = "Sexe",
size = "Nombre d'observations"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1)
)
ggplot(tx_erreur_fin, aes(x = risque_erreur, y = 1 - tx_detect)) +
geom_point(
aes(color = sexe.x, size = id_total),
alpha = 0.8
) +
geom_smooth(
method = "lm",
se = TRUE,
color = "red",
fill = "pink",
alpha = 0.3
) +
scale_color_manual(values = c("f" = "#E41A1C", "m" = "#377EB8")) +
scale_size_continuous(range = c(2, 8)) +
labs(
title = "Relation entre risque d'erreur (auto-évaluation) et non-détection",
x = "Risque d'erreur basé sur l'auto-évaluation",
y = "Taux de non-détection",
color = "Sexe",
size = "Nombre d'observations"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1)
)
ggsave(
filename = "risque_erreur_non_detection.png",
plot = last_plot(),
width = 18,
height = 14,
units = "cm",
dpi = 300
)
p <- ggplot(tx_erreur_fin, aes(x = risque_erreur, y = 1 - tx_detect)) +
geom_point(
aes(color = sexe.x, size = id_total),
alpha = 0.8
) +
geom_smooth(
method = "lm",
se = TRUE,
color = "red",
fill = "pink",
alpha = 0.3
) +
scale_color_manual(values = c("f" = "#E41A1C", "m" = "#377EB8")) +
scale_size_continuous(range = c(2, 8)) +
labs(
title = "Relation entre risque d'erreur (auto-évaluation) et non-détection",
x = "Risque d'erreur basé sur l'auto-évaluation",
y = "Taux de non-détection",
color = "Sexe",
size = "Nombre d'observations"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1)
)
p  # affiche le graphique
ggsave(
filename = "risque_erreur_non_detection.png",
plot = p,
width = 18,
height = 14,
units = "cm",
dpi = 300
)
mod_lin <- lm((1 - tx_detect) ~ risque_erreur, data = tx_erreur_fin)
summary(mod_lin)
ggplot(tx_erreur_fin, aes(x = tx_erreur, y = 1 - tx_detect)) +
geom_point(
aes(color = sexe.x, size = id_total),
alpha = 0.8
) +
geom_smooth(
method = "lm",
se = TRUE,
color = "red",
fill = "pink",
alpha = 0.3
) +
geom_text_repel(
aes(label = Observateur, color = sexe.x),
size = 3,
max.overlaps = Inf,
force = 5,
box.padding = 0.6,
point.padding = 0.5,
segment.color = "grey60",
segment.size = 0.4
) +
scale_color_manual(values = c("f" = "#E41A1C", "m" = "#377EB8")) +
scale_size_continuous(range = c(2, 8)) +
labs(
title = "Relation entre taux d'erreur d'attribution et non-détection",
x = "Taux d'erreur d'attribution de la phénologie",
y = "Taux de non-détection",
color = "Sexe",
size = "Nombre d'observations"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1)
)
```
ggplot(tx_erreur_fin, aes(x = risque_erreur, y = 1 - tx_detect)) +
geom_point(
aes(color = sexe.x, size = id_total),
alpha = 0.8
) +
geom_smooth(
method = "lm",
se = TRUE,
color = "red",
fill = "pink",
alpha = 0.3
) +
geom_text_repel(
aes(label = Observateur, color = sexe.x),
size = 3,
max.overlaps = Inf,
force = 5,
box.padding = 0.6,
point.padding = 0.5,
segment.color = "grey60",
segment.size = 0.4
) +
scale_color_manual(values = c("f" = "#E41A1C", "m" = "#377EB8")) +
scale_size_continuous(range = c(2, 8)) +
labs(
title = "Relation entre risque d'erreur (auto-évaluation) et non-détection",
x = "Risque d'erreur basé sur l'auto-évaluation",
y = "Taux de non-détection",
color = "Sexe",
size = "Nombre d'observations"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1)
)
library(ggpubr)
cols_sexe <- c("f" = "#E41A1C", "m" = "#377EB8")
### 1) Risque d'erreur
ggplot(tx_erreur_fin, aes(x = sexe.x, y = risque_erreur, fill = sexe.x)) +
geom_boxplot(alpha = 0.7) +
scale_fill_manual(values = cols_sexe) +
stat_compare_means(method = "wilcox.test", label = "p.format") +
labs(
title = "Risque d'erreur selon le sexe",
x = "Sexe",
y = "Risque d'erreur"
) +
theme_minimal()
### 2) Taux de détection
ggplot(tx_erreur_fin, aes(x = sexe.x, y = tx_detect, fill = sexe.x)) +
geom_boxplot(alpha = 0.7) +
scale_fill_manual(values = cols_sexe) +
stat_compare_means(method = "wilcox.test", label = "p.format") +
labs(
title = "Taux de détection selon le sexe",
x = "Sexe",
y = "Taux de détection"
) +
theme_minimal()
### 3) Taux d'erreur d'attribution
ggplot(tx_erreur_fin, aes(x = sexe.x, y = tx_erreur, fill = sexe.x)) +
geom_boxplot(alpha = 0.7) +
scale_fill_manual(values = cols_sexe) +
stat_compare_means(method = "wilcox.test", label = "p.format") +
labs(
title = "Taux d'erreur d'attribution selon le sexe",
x = "Sexe",
y = "Taux d'erreur"
) +
theme_minimal()
library(ggpubr)
cols_sexe <- c("f" = "#E41A1C", "m" = "#377EB8")
### 1) Risque d'erreur
ggplot(tx_erreur_fin, aes(x = sexe.x, y = risque_erreur, fill = sexe.x)) +
geom_boxplot(alpha = 0.7) +
scale_fill_manual(values = cols_sexe) +
stat_compare_means(method = "wilcox.test", label = "p.format") +
labs(
title = "Risque d'erreur selon le sexe",
x = "Sexe",
y = "Risque d'erreur"
) +
theme_minimal()
### 2) Taux de détection
ggplot(tx_erreur_fin, aes(x = sexe.x, y = tx_detect, fill = sexe.x)) +
geom_boxplot(alpha = 0.7) +
scale_fill_manual(values = cols_sexe) +
stat_compare_means(method = "wilcox.test", label = "p.format") +
labs(
title = "Taux de détection selon le sexe",
x = "Sexe",
y = "Taux de détection"
) +
theme_minimal()
### 3) Taux d'erreur d'attribution
ggplot(tx_erreur_fin, aes(x = sexe.x, y = tx_erreur, fill = sexe.x)) +
geom_boxplot(alpha = 0.7) +
scale_fill_manual(values = cols_sexe) +
stat_compare_means(method = "wilcox.test", label = "p.format") +
labs(
title = "Taux d'erreur d'attribution selon le sexe",
x = "Sexe",
y = "Taux d'erreur"
) +
theme_minimal()
