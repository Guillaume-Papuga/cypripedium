---
title: "Fourtier_cypripedium"
author: "Galadriel"
format: html
editor: visual
---

# Chargement des packages

```{r}
library(tidyverse)
library(MASS)
library(ade4)
library(ggalluvial)

```

# Ouverture des tableaux de données

```{r}
recouvrement <- read.csv("data/raw/Recouvrement VF.csv",sep = ";")
unique(recouvrement$Site)

verification <- read.csv("data/raw/detections_individuelles_verifsTC+LD_18dec.csv", sep = ";")
#Problème d'espace à régler pour verification
unique(verification$site)
verification$site <- trimws(verification$site)
unique(verification$site)

data_original <- read.csv("data/raw/Taille et phéno verif LD.csv", sep = ";")
unique(data_original$site)
#enlever les accents
data_original <- data_original %>% 
  mutate(site
         = case_when(
    site == "Combe Michaut" ~ "Combe Michaut",
    site == "Tête Cendrée Bas" ~ "Tete Cendree Bas",
    site == "Tête Cendrée Haut" ~ "Tete Cendree Haut",
    site == "Vigne au Renard" ~ "Vigne au Renard",
    site == "Val Clavin" ~ "Val Clavin"
  ))
unique(data_original$site)

experience <- read.csv("data/raw/Experience_des_observateurs_VF.csv", sep = ";")
#Ajout de l'information du sexe des observateurs (à partir de recherches internet)
experience$sexe <- c("m","f","m","m","m","f","m","m","m","f","f","f","f","m","f","m","m","m","m","m","f","f","f","m","f","m","f","m","f","f","f","m","f","f","m")


```

#Analyse tableau recouvrements végétaux ###Pour chaque strate de recouvrement

***Strate muscilagineuse***

```{r}
#| echo: false
ggplot(recouvrement, aes(x = Quadrat, y = S_muscinale, color = Site))+
  geom_line()

```

***Strate herbacéee***

```{r}
#| echo: false
ggplot(recouvrement, aes(x = Quadrat, y = S_herbacee, color = Site))+
  geom_line()

```

***Strate arbustive basse***

```{r}
#| echo: false
ggplot(recouvrement, aes(x = Quadrat, y = S_arbustive_basse, color = Site))+
  geom_line()

```

***Strate arbustive haute***

```{r}
#| echo: false
ggplot(recouvrement, aes(x = Quadrat, y = S_arbustive_haute, color = Site))+
  geom_line()

```

***Strate arborescente***

```{r}
#| echo: false
ggplot(recouvrement, aes(x = Quadrat, y = S_arborescente, color = Site))+
  geom_line()
```

###Transformation strates en facteur

```{r}
recouvrement_par_strate <- recouvrement %>%
  pivot_longer(
    cols = c(-Site, -Quadrat, -ID_Quadrat, starts_with("S_")),
    names_to = "Strate",
    values_to = "Recouvrement"
  ) %>% 
  arrange(Strate)
  
```

####Visualisation des données #####Pour chaque site

***Combe Michaut***

```{r}
#| echo: false
recouvrement_par_strate %>% 
  filter(Site == "Combe Michaut") %>%
  ggplot(aes(x = factor(Quadrat), y = Recouvrement, color = Strate))+
  geom_point(position= "dodge") 

```

***Val Clavin***

```{r}
#| echo: false
recouvrement_par_strate %>% 
  filter(Site == "Val Clavin") %>%
  ggplot(aes(x = factor(Quadrat), y = Recouvrement, color = Strate))+
  geom_point(position= "dodge") 

```

***Vigne au Renard***

```{r}
#| echo: false
recouvrement_par_strate %>% 
  filter(Site == "Vigne au Renard") %>%
  ggplot(aes(x = factor(Quadrat), y = Recouvrement, color = Strate))+
  geom_point(position= "dodge") 

```

***Tete cendree haut***

```{r}
#| echo: false
recouvrement_par_strate %>% 
  filter(Site == "Tete cendree haut") %>%
  ggplot(aes(x = factor(Quadrat), y = Recouvrement, color = Strate))+
  geom_point(position= "dodge") 

```

#####Pour tous les sites ######Boxplot

```{r}
#| echo: false
ggplot(recouvrement_par_strate, aes(x = Strate, y = Recouvrement, color = Site))+
  geom_boxplot(position= "dodge") 

```

######AFD

```{r}
afd_recouvrement<-lda(Site~S_muscinale      +S_herbacee+S_arbustive_basse+S_arbustive_haute+S_arborescente   , data = recouvrement)

#on centre et norme les données
newdata<-as.data.frame(scale(recouvrement[,4:8])) 
names(newdata)
attach(recouvrement)
afd2<-lda(Site~S_muscinale      +S_herbacee+S_arbustive_basse+S_arbustive_haute+S_arborescente   , data = newdata)
afd2
plot(afd2)
manova <- manova(as.matrix(recouvrement[,4:8])~Site)
summary(manova, "Pillai")
summary(manova, "Wilks")

pred<-predict(afd2)
names(pred)
table(Site,pred$class)

#- Validation par jacknife en utilisant CV=T

afd2= lda(Site~S_muscinale      +S_herbacee+S_arbustive_basse+S_arbustive_haute+S_arborescente   , data = newdata, CV=TRUE)
names(afd2)
table(Site, afd2$class)

afd3=discrimin(dudi.pca(recouvrement[,4:8],scannf=F, nf = 3),factor(Site)) # se base sur une ACP centrée réduite et permet d'avoir des coéfficients standardisés 
names(afd3)
afd3$eig # interpréter les ratios variabilité intergroupes/variabilité intragroupe
sqrt(afd3$eig/(1+afd3$eig))

# NB : la fonction discrimin () est différente de LDA : réalise une ACP sur les barycentres des groupes de l'ACP initial. 

s.arrow(afd3$fa) # projection des variables sur les fonctions discriminantes = coef standardisés

s.class(afd3$li, factor(Site)) # projection des individus regroupés en fonction des groupes d'appartendance

rand=rtest(afd3,1000) # MANOVA non paramétrique (test de Pillai non paramétrique)
plot(rand)

```

#Analyse tableau vérification

```{r}
ggplot(verification, aes(x = juv, fill = site))+
  geom_bar(position = "dodge") +
  facet_wrap(~ session)+
  labs(x = "Présence des juvéniles", y = "Nombre d'occurences")
```

```{r}
ggplot(verification, aes(x = non_fleuri, fill = site))+
  geom_bar(position = "dodge") +
  facet_wrap(~ session)+
  labs(x = "Présence des non fleuris", y = "Nombre d'occurences")
```

```{r}
ggplot(verification, aes(x = fleur, fill = site))+
  geom_bar(position = "dodge") +
  facet_wrap(~ session)+
  labs(x = "Présence des fleurs", y = "Nombre d'occurences")
```

```{r}
ggplot(verification, aes(x = fleurs_fanees, fill = site))+
  geom_bar(position = "dodge") +
  facet_wrap(~ session)+
  labs(x = "Présence des fleurs fanées", y = "Nombre d'occurences")
```

```{r}
ggplot(verification, aes(x = fruit, fill = site))+
  geom_bar(position = "dodge") +
  facet_wrap(~ session)+
  labs(x = "Présence des fruits", y = "Nombre d'occurences")
```

```{r}
ggplot(verification, aes(x = adequation, fill = site))+
  geom_bar(position = "dodge") +
  facet_wrap(~ session)+
  labs(x = "Adéquation des observations avec le contrôleur", y = "Nombre d'occurences")
```

```{r}
ggplot(verification, aes(x = adequation, fill = observateur))+
  geom_boxplot(position = "dodge")+
  labs(x = "Adéquation des observations avec le contrôleur", y = "Observateur")
```

##Transformation phenologie en facteur

```{r}
verification2 <- verification %>% 
  pivot_longer(
    cols = c(juv, non_fleuri, fleur, fleurs_fanees, fruit),
    names_to = "phenologie",
    values_to = "presence"
  )

desired_order <- c("juv", "non_fleuri", "fleur", "fleurs_fanees", "fruit")
verification2$phenologie <- factor(verification2$phenologie,
                                   levels = desired_order)

```

###Analyses phénologie

```{r}
ggplot(verification2, aes(x = presence, fill = site))+
  geom_bar(position = "dodge")+
  facet_grid(session~phenologie)


```

```{r}
verification2 %>% 
  filter(presence == 1) %>% 
ggplot(aes(x = presence, fill = site))+
  geom_bar(position = "dodge")+
  facet_grid(session~phenologie)


```

###Analyse adéquation

```{r}
verification3 <- verification %>% 
  group_by(observateur) %>% 
  count(adequation) %>% 
  pivot_wider(
    names_from = adequation,
    values_from = n,
    names_glue = "{ifelse(adequation == 1, 'id_valide', 'id_fausse')}"
  ) %>% 
  replace_na(list(id_fausse = 0,
                  id_valide = 0)) %>% 
    mutate(tx_erreur = id_fausse / (id_valide + id_fausse),
           id_total = id_fausse + id_valide)

#Deux observateurs avec adéquation NA
verification %>% 
  filter(is.na(adequation))

ggplot(data = verification3, aes(x = tx_erreur, y = id_total, color = ))+
  geom_point()
cor.test(verification3$tx_erreur, verification3$id_total)
cor.test(verification3$tx_erreur, verification3$id_total, method = "spearman")

```

####Taux d'erreur par observateur

```{r}
ggplot(verification3, aes(x = tx_erreur, y = observateur)) +
  geom_segment(aes(x = 0, xend = tx_erreur, y = observateur, yend = observateur), color = "grey70") +
  geom_point(size = 4, color = "tomato") +
  labs(x = "Taux d'erreur", y = "Observateur") +
  theme_minimal()

ggplot(verification3, aes(x = tx_erreur, y = observateur)) +
  geom_segment(aes(x = 0, xend = tx_erreur,
                   y = observateur, yend = observateur),
               color = "grey70") +
  geom_point(aes(size = id_total), color = "tomato") +
  geom_text(aes(label = id_total), 
            nudge_x = 0.02,
            size = 2) +
  scale_size_continuous(name = "Nombre d'observations")+
  labs(x = "Taux d'erreur", y = "Observateur") +
  theme_minimal()

```

####Taux d'erreur par observateur en fonction du site

```{r}
verification4 <- verification %>% 
  left_join(verification3, by = "observateur")

ggplot(data = verification4, aes(x = tx_erreur, y = id_total))+
  geom_point()+
  facet_wrap(~site)
```

####Taux d'erreur par site

```{r}
verification5 <- verification %>% 
  group_by(site) %>% 
  count(adequation) %>% 
  pivot_wider(
    names_from = adequation,
    values_from = n,
    names_glue = "{ifelse(adequation == 1, 'id_valide', 'id_fausse')}"
  ) %>% 
  replace_na(list(id_fausse = 0,
                  id_valide = 0)) %>% 
    mutate(tx_erreur = id_fausse / (id_valide + id_fausse),
           id_total = id_fausse + id_valide)

ggplot(data = verification5, aes(x = tx_erreur, y=id_total, color = site))+
  geom_point()

```

#Taux d'erreur par site et par quadrat

```{r}
verification6 <- verification %>% 
  group_by(site, numero_quadrat) %>% 
  count(adequation) %>% 
  pivot_wider(
    names_from = adequation,
    values_from = n,
    names_glue = "{ifelse(adequation == 1, 'id_valide', 'id_fausse')}"
  ) %>% 
  replace_na(list(id_fausse = 0,
                  id_valide = 0)) %>% 
    mutate(tx_erreur = id_fausse / (id_valide + id_fausse),
           id_total = id_fausse + id_valide)

ggplot(data = verification6, aes(x = tx_erreur, y=id_total))+
  geom_point()+
  facet_wrap(~site)

```

####Taux d'erreur par observateur en fonction des sessions

```{r}
verification7 <- verification %>% 
  group_by(observateur, session) %>% 
  count(adequation) %>% 
  pivot_wider(
    names_from = adequation,
    values_from = n,
    names_glue = "{ifelse(adequation == 1, 'id_valide', 'id_fausse')}"
  ) %>% 
  replace_na(list(id_fausse = 0,
                  id_valide = 0)) %>% 
    mutate(tx_erreur = id_fausse / (id_valide + id_fausse),
           id_total = id_fausse + id_valide)


ggplot(verification7, aes(x = tx_erreur, y = observateur)) +
  geom_segment(aes(x = 0, xend = tx_erreur,
                   y = observateur, yend = observateur),
               color = "grey70") +
  geom_point(aes(size = id_total), color = "tomato") +
  geom_text(aes(label = id_total), 
            nudge_x = 0.02,
            size = 2) +
  scale_size_continuous(name = "Nombre d'observations")+
  labs(x = "Taux d'erreur", y = "Observateur") +
  facet_wrap(~session)


ggplot(data = verification7, aes(x = session, y = tx_erreur))+
  geom_line(aes(color=observateur))

ggplot(data = verification7, aes(x = as.factor(session), y = tx_erreur))+
  geom_boxplot()
```

####Taux d'erreur comparé à autonotation

```{r}
experience <- experience %>%
  mutate(score_moyen = rowMeans(across(A:E)))

experience <- experience %>%
  mutate(score_moyen = rowMeans(across(A:E)))
experience <- experience %>%
  mutate(score_moyen = rowMeans(across(A:E), na.rm = TRUE))

# Tri du plus compétent au moins compétent
experience %>%
  arrange(desc(score_moyen))

# Poids de fiabilité (normalisé entre 0 et 1)
experience <- experience %>%
  mutate(fiabilite = score_moyen / 10,
         risque_erreur = 1 - fiabilite)

experience <- experience %>%
  rowwise() %>%
  mutate(ecart_type = sd(c_across(A:E))) %>%
  ungroup()

experience <- experience %>%
  arrange(desc(risque_erreur)) %>%
  mutate(ID.observateur = factor(ID.observateur, levels = ID.observateur))


ggplot(experience, aes(x = ID.observateur, y = risque_erreur, fill = sexe)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("f" = "red", "m" = "blue")) +
  theme_minimal() +
  labs(title = "Risque d’erreur estimé par observateur",
       x = "Observateur", y = "Risque d’erreur (1 - fiabilité)")+geom_errorbar(
         aes(
           ymin = risque_erreur - (ecart_type/10),
           ymax = risque_erreur + (ecart_type/10)
         ),
         width = 0.2,
         linewidth = 0.6
       )



```

#COmparaison tx d'erreur et auutonotation

```{r}
experience2 <- experience %>% 
  inner_join(verification3, by = join_by("Observateur" == "observateur"))

ggplot(data = experience2, aes( x = risque_erreur, y = tx_erreur))+
  geom_point()+
  geom_smooth(method = "lm")+
  labs(x = "Risque d'erreur basé sur autonotation", y = "Taux d'erreur d'attribution de la phénologie")
```

#Analyse tableau Taille et phéno verif LD

```{r}
transition_pheno <- data_original %>% 
  dplyr::select(ID_ind, phenoS1, phenoS2, phenoS3)

trans_12 <- transition_pheno %>%
  filter(!is.na(phenoS1), !is.na(phenoS2)) %>%
  count(from = phenoS1, to = phenoS2)

trans_23 <- transition_pheno %>%
  filter(!is.na(phenoS2), !is.na(phenoS3)) %>%
  count(from = phenoS2, to = phenoS3)

transition_pheno2 <- data_original %>% 
  dplyr::select(site, ID_ind, phenoS1, phenoS2, phenoS3)

transition_pheno3 <- transition_pheno2 %>% 
  pivot_longer(
    cols = c(phenoS1, phenoS2, phenoS3),
    names_to = "session",
    values_to = "phenologie"
  )

ggplot(transition_pheno3,
       aes(x = session,
           stratum = phenologie,
           alluvium = ID_ind,
           fill = phenologie)) +
  geom_flow(alpha = 0.2,  color = "black", linewidth = 0.1) +
  geom_stratum() +
  scale_x_discrete(breaks = c(1, 2, 3),
                     labels = c("Session 1", "Session 2", "Session 3")) +
  labs(
    x = "Session",
    y = "Number of individuals",
    fill = "Phenology",
    title = "Phenological transitions by individual"
  ) +
  facet_wrap(~site)

```

#Analyse proba de détection

```{r}

#ajout information session à l'ID individuel####
#pour tableau vérification des observateurs
verification2<- verification %>% 
  mutate(id_ind_fin = paste(ID_ind, session, sep = ".")) %>% 
  dplyr::select(id_ind_fin, everything())
#pour tableau des évaluateurs
##mettre stade phéno en ligne et non en colonne 
data_original2 <- data_original %>%
  dplyr::select(-tailleS1, -tailleS2, -tailleS3, -nbfleurs, -nbfruits, -predation) %>% 
  pivot_longer(
    cols = c(phenoS1, phenoS2, phenoS3),
    names_to = "session",
    values_to = "phenologie_verif"
  )%>% 
   mutate(session = case_when(
    session == "phenoS1" ~ 1,
    session == "phenoS2" ~ 2,
    session == "phenoS3" ~ 3
  )
   ) %>% 
  mutate(phenologie_verif
         = case_when(
    phenologie_verif == "j" ~ "juv",
    phenologie_verif == "nf" ~ "non_fleuri",
    phenologie_verif == "f" ~ "fleur",
    phenologie_verif == "ff" ~ "fleurs_fanees",
    phenologie_verif == "F" ~"fruit"
  ))

##mettre taille en ligne et non en colonne
data_original3 <- data_original %>% 
  dplyr::select(tailleS1, tailleS2, tailleS3) %>% 
  pivot_longer(
    cols = c(tailleS1, tailleS2, tailleS3),
    names_to = "session",
    values_to = "taille"
  ) %>% 
   mutate(session = case_when(
    session == "tailleS1" ~ 1,
    session == "tailleS2" ~ 2,
    session == "tailleS3" ~ 3
  )
   )

#enlever session car déjà présent sur autre data frame
data_original3 <- data_original3 %>% 
  dplyr::select(-session)

#ajout des deux tableaux + enlever lignes sans info  à cause d'observation d'un individu à partir de session 2 ou 3
data_original4 <- cbind(data_original2, data_original3) %>% 
  filter(!is.na(taille)) #enlever lignes avec pas d'infos

#vérifier si manque des informations par rapport à phénologie
data_original4 %>% 
  filter(is.na(phenologie_verif))

#ajout variable individuelle complète
data_original_obs <- data_original4 %>% 
  mutate(id_ind_fin = paste(ID_ind, session, sep = ".")) %>% 
  dplyr::select(id_ind_fin, everything())

#prendre en compte stade phéno observé par observateur
verification3 <- verification2 %>% 
  pivot_longer(
    cols = c(juv, non_fleuri, fleur, fleurs_fanees, fruit),
    names_to = "phenologie",
    values_to = "presence"
  )  
  
#garder seulement st phéno observé par observateur
verification_obs <- verification3 %>% 
  filter(presence == 1)
  
#Vérifier nb individus
str(unique(verification_obs$id_ind_fin))
str(unique(data_original_obs$id_ind_fin))
str(data_original_obs$id_ind_fin)
str(verification_obs$id_ind_fin)
#à priori 66 individus jamais vus par observateurs

#extraire liste de tous les individus
nb_individu <- data.frame(id_ind_fin = data_original_obs$id_ind_fin)

#extraire liste individus dans test de détection
nb_ind_obs <- data.frame(id_ind_fin = unique(verification_obs$id_ind_fin))

#individus manquants
nb_individu_manquant <- nb_individu %>% 
  anti_join(nb_ind_obs, by = "id_ind_fin")

#reprendre données originales sur les valeurs manquantes
nb_individu_manquant_original <- data_original_obs %>% 
  semi_join(nb_individu_manquant, by = "id_ind_fin") 
  

#joindre à ces données manquantes les valeurs du tableau observateur
nb_individu_manquant_final <- nb_individu_manquant_original %>% 
  left_join(verification_obs, by = "id_ind_fin") %>% 
  dplyr::select(-ends_with(".y")) %>% 
  rename_with(~ sub("\\.x$", "", .x), ends_with(".x"))

#Joindre au fichier original les informations des évaluateurs
data_verification_original <- verification_obs %>% 
  left_join(data_original_obs, by = "id_ind_fin") %>% 
  dplyr::select(-ends_with(".y")) %>% 
  rename_with(~ sub("\\.x$", "", .x), ends_with(".x"))

#mettre les colomnes dans le bon ordre
nb_individu_manquant_final <- nb_individu_manquant_final %>% 
  dplyr::select(id_ind_fin, session, site, date, numero_quadrat, ID_quadrat, marquage, ID_ind, observateur, adequation, phenologie, presence, quadrat, phenologie_verif, taille)

#joindre ces données manquantes à tableau observateurs
tab_detection <- rbind(data_verification_original, nb_individu_manquant_final)

#créer nouvelle valeur adéquation
tab_detection <- tab_detection %>% 
  mutate(adequation_reel = if_else(
    phenologie == phenologie_verif, 1, 0
  ),
  comparaison_adequation = if_else(
    adequation_reel==adequation, 1, 0
  )
  )

#Taux d'erreur dans note d'adéquation
sum(tab_detection$comparaison_adequation == 0, na.rm = T) / nrow(tab_detection)

#vérifier nombre d'observateurs par session et par quadrat
nb_verif_quadrat <- verification %>% 
  group_by(session, site, numero_quadrat) %>% 
  summarise(
    nb_observateurs = n_distinct(observateur),
    .groups = "drop"
  )
nrow(nb_verif_quadrat)
nb_verif_quadrat <- nb_verif_quadrat %>% 
  mutate(site = case_when(
    site == "Combe Michaut" ~ "CM",
    site == "Tete Cendree Bas" ~ "TCb",
    site == "Tete Cendree Haut" ~ "TCh",
    site == "Vigne au Renard" ~ "VaR",
    site == "Val Clavin" ~ "VC"
  ),
  ID = "Q")

nb_verif_quadrat <- nb_verif_quadrat %>% 
  mutate(id_quadrat = paste(ID, numero_quadrat, sep = ""),
         id_quadrat_fin = paste(site, id_quadrat, session, sep =".")) %>% 
  dplyr::select(id_quadrat_fin, everything())

nb_obs_quadrat <- data_original_obs %>% 
  group_by(session, site, quadrat) %>% 
  count()
nrow(nb_obs_quadrat)

nb_quadrat_final <- tab_detection %>% 
  group_by(session, site, quadrat) %>% 
  summarise(
    nb_observateurs = n_distinct(observateur),
    .groups = "drop"
  ) %>% 
  filter(!is.na(quadrat))
nrow(nb_quadrat_final)

nb_quadrat_manquant <- nb_individu_manquant_final %>% 
  group_by(session, ID_quadrat) %>% 
  summarise(
    nb_observateurs = n_distinct(observateur),
    .groups = "drop"
  )
nrow(nb_quadrat_manquant)
#individus manquants dans 27 quadras

nb_quadrat_manquant <- nb_quadrat_manquant %>% 
  mutate(id_quadrat_fin = paste(ID_quadrat, session, sep = ".")) %>% 
  dplyr::select(id_quadrat_fin, everything())

test <- nb_quadrat_manquant %>% 
  anti_join(nb_verif_quadrat, by = "id_quadrat_fin")

#On a bien tous les quadra d'observés juste pas tous les individus

str(tab_detection)

#Pour le moment j'ai un tableau avec tous les individus observés mais je n'ai pas l'info sur individus non observés par observateurs
#il me faut à chaque fois le nb de quadrats observés par observateurs pour calculer le nombre d'observateurs par quadrat
verification_obs_quadrat <- verification %>% 
  mutate(id_quadrat_fin = paste(ID_quadrat, session, sep = ".")) %>% 
  group_by(id_quadrat_fin, observateur) %>% 
  count()

#Ajouter à tableau détection id_quadrat_fin
tab_detection <- tab_detection %>% 
  mutate(id_quadrat_fin = paste(ID_quadrat, session, sep = "."))

#Vérifier que pas de NA crées
tab_detection[is.na(tab_detection$id_quadrat_fin), ]

#Calculer le nombre d'individus par quadrat
nb_indiv_quadrat <- data_original_obs %>% 
    mutate(id_quadrat_fin = paste(ID_quadrat, session, sep = ".")) %>% 
  group_by(id_quadrat_fin) %>% 
  summarise(
    nb_individus = n_distinct(ID_ind),
    .groups = "drop"
  )

#Maintenant je compare ce nombre au nombre observé par mes observateurs
difference_ind <- verification_obs_quadrat %>% 
  full_join(nb_indiv_quadrat, by = "id_quadrat_fin")

#Taux de detection par observateur
difference_ind <- difference_ind %>% 
  mutate(detection = n/nb_individus)

#sortir les identifiants de tous les individus possibles
individus_par_quadrat <- tab_detection %>%
  distinct(id_quadrat_fin, ID_ind)

#combinaisons de tous les individus possibles avec les observateurs
grille_complete <- difference_ind %>%
  dplyr::select(id_quadrat_fin, observateur) %>%
  distinct() %>%
  left_join(individus_par_quadrat, by = "id_quadrat_fin", relationship = "many-to-many")

#ajouter les informations de detection dans ma grille complete
tab_complet <- grille_complete %>%
  left_join(
    tab_detection %>%
      mutate(detection = 1) %>%
      dplyr::select(id_quadrat_fin, observateur, ID_ind, detection),
    by = c("id_quadrat_fin", "observateur", "ID_ind")
  ) %>%
  mutate(
    detection = ifelse(is.na(detection), 0, detection)
  )

#Vérifier que ça a marché en comparant le nombre de détections calculées vs le nombre de détection par quadrat
tab_complet %>%
  group_by(id_quadrat_fin, observateur) %>%
  summarise(
    n_detectes = sum(detection),
    .groups = "drop"
  ) %>%
  left_join(difference_ind, by = c("id_quadrat_fin", "observateur")) %>% 
  filter(n_detectes != n)

#récuperer les informations biologiques par individus
infos_individus <- tab_detection %>%
  dplyr::select(
    ID_ind,
    id_quadrat_fin,
    phenologie_verif,
    site,
    quadrat,
    session,
    taille
  ) %>%
  distinct()

#Vérifier que j'ai bien une info par individu
infos_individus %>%
  count(ID_ind, id_quadrat_fin) %>%
  filter(n > 1)

#Ajouter ces informations à mon tableau de détection
tab_complet <- tab_complet %>%
  left_join(
    infos_individus,
    by = c("ID_ind", "id_quadrat_fin")
  )


```

#Préparation jeu de données pour crdms pour analyse dynamique des pops#### #Point méthodologique Le Multistate va être utilisé pour prendre en compte transitions phénologiques des individus Le robust design pour prendre en compte variations entre sessions étant des périodes primaires et en même temps prendre en compte plusieurs observations dans chaque session (observateurs) étant notre période secondaire. Le closed correspond au fait qu'on ne considère pas de variations des paramètres démographiques au sein de notre période secondaire

#La variable site ne va pas être utilisé en état car il n'y a probablement pas de migrations entre sites (les plantes ne bougeant pas) mais comme covariable car chaque site peut influencer la survie des individus et n'a pas la même densité d'individus

La variable taille va aussi être utilisé comme covariable car elle peut influencer la détection (à voir si on la met car en pratique très liée à stade phénologiques...)

```{r}
#Résumer la phénologie en lettres pour crdms
unique(tab_complet$phenologie_verif)
#filtrer pour garder seuelement lignes sans NA
tab_complet <- tab_complet %>%
  filter(!is.na(phenologie_verif))

unique(tab_complet$phenologie_verif)
tab_complet <- tab_complet %>%
  mutate(
    phenologie = case_when(
      phenologie_verif == "juv" ~ "j",
      phenologie_verif == "non_fleuri" ~ "nf",
      phenologie_verif == "fleur" ~ "f",
      phenologie_verif == "fruit" ~ "F",
      phenologie_verif == "fleurs_fanees" ~ "ff",
      
    )
  )

#Donner un chiffre à chaque observateur différent
tab_complet <- tab_complet %>%
  group_by(session) %>%
  mutate(sec = as.integer(factor(observateur))) %>%
  ungroup()

#Histoire de captures
ch_tab <- tab_complet %>%
  arrange(ID_ind, session, sec) %>%
  mutate(obs = ifelse(detection == 1, state, "0")) %>%
  group_by(ID_ind, session) %>%
  summarise(ch_sess = paste0(obs, collapse = ""), .groups = "drop")

#prendre infos covariables
ind_cov <- tab_complet %>%
  dplyr::select(ID_ind, session, site, quadrat, taille) %>%
  distinct()

#ajouter l'info
ch_data <- left_join(ch_tab, ind_cov, by = c("ID_ind", "session"))

#Concaténer les sessions pour avoir une seule histoire de capture
ch_data_final <- ch_data %>% 
  group_by(ID_ind) %>% 
  summarise(ch=paste(ch_sess, collapse = "", .groups = "drop"))

#Ajouter les covariables fixes
cov_fixed <- tab_complet %>% 
  dplyr::select(ID_ind, site, quadrat) %>% 
  distinct()

ch_data_final <- left_join(ch_data_final, cov_fixed, by = "ID_ind")

#nombre d'occasions secondaires par session
nocc <- tab_complet %>% 
  distinct(session, sec) %>% 
  count(session) %>% 
  arrange(session) %>% 
  pull(n)

library(RMark)
proc <- process.data(
  ch_data_final,
  model = "crdms",
  nocc = nocc,
  strata.labels = c("j", "nf", "f", "F", "ff")
)
```

#Taux d'erreur réel observateurs

```{r}
tx_erreur <- tab_complet %>% 
  group_by(observateur) %>% 
  summarise(nb_ind = n(), nb_detect = sum(detection, na.rm = TRUE),
            tx_detect = nb_detect/nb_ind)

tx_erreur_fin <- experience2 %>% 
  inner_join(tx_erreur, by = join_by("Observateur" == "observateur"))

ggplot(data = tx_erreur_fin, aes(x = tx_erreur, y = 1 - tx_detect))+
  geom_point()+
  geom_smooth(method = "lm")+
  labs(x = "Taux d'erreur d'attribution de phénologie",
       y = "taux de non détection")
cor.test(tx_erreur_fin$tx_detect, tx_erreur_fin$tx_erreur, method = "spearman")

ggplot(data = tx_erreur_fin, aes( x = risque_erreur, y = tx_erreur))+
  geom_point()+
  geom_smooth(method = "lm")+
  labs(x = "Risque d'erreur basé sur autonotation", y = "Taux d'erreur d'attribution de la phénologie")

ggplot(data = tx_erreur_fin, aes( x = risque_erreur, y = 1 - tx_detect))+
  geom_point()+
  geom_smooth(method = "lm")+
  labs(x = "Risque d'erreur basé sur autonotation", y = "Taux de non détection")

model1_autonotation <- lm(risque_erreur ~ tx_erreur + tx_detect, data = tx_erreur_fin)

summary(model1_autonotation)
anova(model1_autonotation)
library(car)
vif(model1_autonotation)

model2_autonotation <- lm(risque_erreur ~ tx_detect, data = tx_erreur_fin)
summary(model2_autonotation)
anova(model2_autonotation)

model3_autonotation <- lm(risque_erreur ~ tx_erreur, data = tx_erreur_fin)
summary(model3_autonotation)
anova(model3_autonotation)

AIC(model1_autonotation, model2_autonotation, model3_autonotation)
```
